;
;=============================================================================
;   PPA DISK DRIVER
;=============================================================================
;
; PARALLEL PORT INTERFACE FOR SCSI DISK DEVICES USING A PARALLEL PORT
; ADAPTER.  PRIMARILY TARGETS PARALLEL PORT IOMEGA ZIP DRIVES.
;
; INTENDED TO CO-EXIST WITH LPT DRIVER.
;
; CREATED BY WAYNE WARTHEN FOR ROMWBW HBIOS.
; MUCH OF THE CODE IS DERIVED FROM FUZIX (ALAN COX).
;
; 5/23/2023 WBW - INITIAL RELEASE
; 5/26/3023 WBW - CLEAN UP, LED ACTIVITY
; 5/27/2023 WBW - ADDED SPP MODE
;
;=============================================================================
;
;  IBM PC STANDARD PARALLEL PORT (SPP):
;  - NHYODYNE PRINT MODULE
;
;  PORT 0 (OUTPUT):
;
;	D7	D6	D5	D4	D3	D2	D1	D0
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;     | PD7   | PD6   | PD5   | PD4   | PD3   | PD2   | PD1   | PD0   |
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;
;  PORT 1 (INPUT):
;
;	D7	D6	D5	D4	D3	D2	D1	D0
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;     | /BUSY | /ACK  | POUT  | SEL   | /ERR  | 0     | 0     | 0     |
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;
;  PORT 2 (OUTPUT):
;
;	D7	D6	D5	D4	D3	D2	D1	D0
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;     | STAT1 | STAT0 | ENBL  | PINT  | SEL   | RES   | LF    | STB   |
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;
;=============================================================================
;
;  MG014 STYLE INTERFACE:
;  - RCBUS MG014 MODULE
;
;  PORT 0 (OUTPUT):
;
;	D7	D6	D5	D4	D3	D2	D1	D0
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;     | PD7   | PD6   | PD5   | PD4   | PD3   | PD2   | PD1   | PD0   |
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;
;  PORT 1 (INPUT):
;
;	D7	D6	D5	D4	D3	D2	D1	D0
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;     |	      |	      |	      | /ERR  | SEL   | POUT  | BUSY  | /ACK  |
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;
;  PORT 2 (OUTPUT):
;
;	D7	D6	D5	D4	D3	D2	D1	D0
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;     | LED   |	      |	      |	      | /SEL  | /RES  | /LF   | /STB  |
;     +-------+-------+-------+-------+-------+-------+-------+-------+
;
;=============================================================================
;
; TODO:
;
; - OPTIMIZE READ/WRITE LOOPS
;
; NOTES:
;
; - THIS DRIVER IS FOR THE ZIP DRIVE PPA INTERFACE.  IT WILL SIMPLY
;   FAIL TO EVEN RECOGNIZE A ZIP DRIVE WITH THE OLDER PPA INTERFACE.
;   THERE DOES NOT SEEM TO BE A WAY TO VISUALLY DETERMINE IF A ZIP
;   DRIVE IS PPA OR PPA.  SIGH.
;
; - THERE ARE SOME HARD CODED TIMEOUT LOOPS IN THE CODE.  THEY ARE
;   WORKING OK ON A 7 MHZ Z80.  THEY ARE LIKELY TO NEED TWEAKING ON
;   FASTER CPUS.
;
; - THIS DRIVER OPERATES PURELY IN NIBBLE MODE.  I SUSPECT IT IS
;   POSSIBLE TO USE FULL BYTE MODE (PS2 STYLE), BUT I HAVE NOT
;   ATTEMPTED IT.
;
; - RELATIVE TO ABOVE, THIS BEAST IS SLOW.  IN ADDITION TO THE
;   NIBBLE MODE READS, THE MG014 ASSIGNS SIGNALS DIFFERENTLY THAN
;   THE STANDARD IBM PARALLEL PORT WHICH NECESSITATES A BUNCH OF EXTRA
;   BIT FIDDLING ON EVERY READ.
;
; - SOME OF THE DATA TRANSFERS HAVE NO BUFFER OVERRUN CHECKS.  IT IS
;   ASSUMED SCSI DEVICES WILL SEND/REQUEST THE EXPECTED NUMBER OF BYTES.
;
; PPA PORT OFFSETS
;
PPA_IODATA	.EQU	0		; PORT A, DATA, OUT
PPA_IOSTAT	.EQU	1		; PORT B, STATUS, IN
PPA_IOCTRL	.EQU	2		; PORT C, CTRL, OUT
PPA_IOSETUP	.EQU	3		; PPI SETUP
;
; SCSI UNIT IDS
;
PPA_SELF	.EQU	7
PPA_TGT		.EQU	6
;
; PPA DEVICE STATUS
;
PPA_STOK	.EQU	0
PPA_STNOMEDIA	.EQU	-1
PPA_STCMDERR	.EQU	-2
PPA_STIOERR	.EQU	-3
PPA_STTO	.EQU	-4
PPA_STNOTSUP	.EQU	-5
;
; PPA DEVICE CONFIGURATION
;
PPA_CFGSIZ	.EQU	12		; SIZE OF CFG TBL ENTRIES
;
; PER DEVICE DATA OFFSETS IN CONFIG TABLE ENTRIES
;
PPA_DEV		.EQU	0		; OFFSET OF DEVICE NUMBER (BYTE)
PPA_MODE	.EQU	1		; OPERATION MODE: PPA MODE (BYTE)
PPA_STAT	.EQU	2		; LAST STATUS (BYTE)
PPA_IOBASE	.EQU	3		; IO BASE ADDRESS (BYTE)
PPA_MEDCAP	.EQU	4		; MEDIA CAPACITY (DWORD)
PPA_LBA		.EQU	8		; OFFSET OF LBA (DWORD)
;
;=============================================================================
; INITIALIZATION ENTRY POINT
;=============================================================================
;
PPA_INIT:
	LD	IY,PPA_CFG		; POINT TO START OF CONFIG TABLE
;
PPA_INIT1:
	LD	A,(IY)			; LOAD FIRST BYTE TO CHECK FOR END
	CP	$FF			; CHECK FOR END OF TABLE VALUE
	JR	NZ,PPA_INIT2		; IF NOT END OF TABLE, CONTINUE
	XOR	A			; SIGNAL SUCCESS
	RET				; AND RETURN
;
PPA_INIT2:
	CALL	NEWLINE			; FORMATTING
	PRTS("PPA:$")			; DRIVER LABEL
;
	PRTS(" IO=0x$")			; LABEL FOR IO ADDRESS
	LD	A,(IY+PPA_IOBASE)	; GET IO BASE ADDRES
	CALL	PRTHEXBYTE		; DISPLAY IT
;
	PRTS(" MODE=$")			; LABEL FOR MODE
	LD	A,(IY+PPA_MODE)		; GET MODE BITS

	LD	HL,PPA_STR_MODE_MAP
	ADD	A,A
	CALL	ADDHLA
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	CALL	WRITESTR
;
	; CHECK FOR HARDWARE PRESENCE
	CALL	PPA_DETECT		; PROBE FOR INTERFACE
	JR	Z,PPA_INIT4		; IF FOUND, CONTINUE
	CALL	PC_SPACE		; FORMATTING
	LD	DE,PPA_STR_NOHW		; NO PPA MESSAGE
	CALL	WRITESTR		; DISPLAY IT
	JR	PPA_INIT6		; SKIP CFG ENTRY
;
PPA_INIT4:
	; UPDATE DRIVER RELATIVE UNIT NUMBER IN CONFIG TABLE
	LD	A,(PPA_DEVNUM)		; GET NEXT UNIT NUM TO ASSIGN
	LD	(IY+PPA_DEV),A		; UPDATE IT
	INC	A			; BUMP TO NEXT UNIT NUM TO ASSIGN
	LD	(PPA_DEVNUM),A		; SAVE IT
;
	; ADD UNIT TO GLOBAL DISK UNIT TABLE
	LD	BC,PPA_FNTBL		; BC := FUNC TABLE ADR
	PUSH	IY			; CFG ENTRY POINTER
	POP	DE			; COPY TO DE
	CALL	DIO_ADDENT		; ADD ENTRY TO GLOBAL DISK DEV TABLE
;
	CALL	PPA_RESET		; RESET/INIT THE INTERFACE
#IF (PPATRACE == 0)
	CALL	PPA_PRTSTAT
#ENDIF
	JR	NZ,PPA_INIT6
;
	; START PRINTING DEVICE INFO
	CALL	PPA_PRTPREFIX		; PRINT DEVICE PREFIX
;
PPA_INIT5:
	; PRINT STORAGE CAPACITY (BLOCK COUNT)
	PRTS(" BLOCKS=0x$")		; PRINT FIELD LABEL
	LD	A,PPA_MEDCAP		; OFFSET TO CAPACITY FIELD
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	LD32			; GET THE CAPACITY VALUE
	CALL	PRTHEX32		; PRINT HEX VALUE
;
	; PRINT STORAGE SIZE IN MB
	PRTS(" SIZE=$")			; PRINT FIELD LABEL
	LD	B,11			; 11 BIT SHIFT TO CONVERT BLOCKS --> MB
	CALL	SRL32			; RIGHT SHIFT
	CALL	PRTDEC32		; PRINT DWORD IN DECIMAL
	PRTS("MB$")			; PRINT SUFFIX
;
PPA_INIT6:
	LD	DE,PPA_CFGSIZ		; SIZE OF CFG TABLE ENTRY
	ADD	IY,DE			; BUMP POINTER
	JP	PPA_INIT1		; AND LOOP
;
;----------------------------------------------------------------------
; PROBE FOR PPA HARDWARE
;----------------------------------------------------------------------
;
; ON RETURN, ZF SET INDICATES HARDWARE FOUND
;
PPA_DETECT:
	; INITIALIZE 8255
	LD	A,(IY+PPA_IOBASE)	; BASE PORT
	ADD	A,PPA_IOSETUP		; BUMP TO SETUP PORT
	LD	C,A			; MOVE TO C FOR I/O
	LD	A,$82			; CONFIG A OUT, B IN, C OUT
	OUT	(C),A			; DO IT
	CALL	DELAY			; BRIEF DELAY FOR GOOD MEASURE
;
	LD	A,$AA \ CALL	PPA_WRITEDATA
	CALL	PPA_DISCONNECT
	CALL	PPA_CONNECT
	LD	A,$06 \ CALL	PPA_WRITECTRL
	CALL	PPA_READSTATUS
;
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
;
	AND	$F0
	CP	$F0
	JR	NZ,PPA_DETECT_FAIL
	LD	A,$04 \ CALL	PPA_WRITECTRL
	CALL	PPA_READSTATUS
;
	CALL	PC_SPACE
	CALL	PRTHEXBYTE
;
	AND	$F0
	CP	$80
	JR	NZ,PPA_DETECT_FAIL
	LD	A,$AA \ CALL	PPA_WRITEDATA
	LD	A,$0C \ CALL	PPA_WRITECTRL
	CALL	PPA_CONNECT
	LD	A,$40 \ CALL	PPA_WRITEDATA
	LD	A,$08 \ CALL	PPA_WRITECTRL
	LD	A,$0C \ CALL	PPA_WRITECTRL
	CALL	PPA_DISCONNECT
;
	XOR	A			; SIGNAL SUCCESS
	RET				; AND RETURN
;
PPA_DETECT_FAIL:
	OR	$FF			; SIGNAL FAILURE
	RET	NZ

;
;=============================================================================
; DRIVER FUNCTION TABLE
;=============================================================================
;
PPA_FNTBL:
	.DW	PPA_STATUS
	.DW	PPA_RESET
	.DW	PPA_SEEK
	.DW	PPA_READ
	.DW	PPA_WRITE
	.DW	PPA_VERIFY
	.DW	PPA_FORMAT
	.DW	PPA_DEVICE
	.DW	PPA_MEDIA
	.DW	PPA_DEFMED
	.DW	PPA_CAP
	.DW	PPA_GEOM
#IF (($ - PPA_FNTBL) != (DIO_FNCNT * 2))
	.ECHO	"*** INVALID PPA FUNCTION TABLE ***\n"
#ENDIF
;
PPA_VERIFY:
PPA_FORMAT:
PPA_DEFMED:
	SYSCHKERR(ERR_NOTIMPL)		; NOT IMPLEMENTED
	RET
;
;
;
PPA_READ:
	CALL	HB_DSKREAD		; HOOK DISK READ CONTROLLER
	LD	A,SCSI_CMD_READ		; SETUP SCSI READ
	LD	(PPA_CMD_RW),A		; AND SAVE IT IN SCSI CMD
	JP	PPA_IO			; DO THE I/O
;
;
;
PPA_WRITE:
	CALL	HB_DSKREAD		; HOOK DISK WRITE CONTROLLER
	LD	A,SCSI_CMD_WRITE	; SETUP SCSI WRITE
	LD	(PPA_CMD_RW),A		; AND SAVE IT IN SCSI CMD
	JP	PPA_IO			; DO THE I/O
;
;
;
PPA_IO:
	LD	(PPA_DSKBUF),HL		; SAVE DISK BUFFER ADDRESS
	CALL	PPA_CHKERR		; CHECK FOR ERR STATUS AND RESET IF SO
	JR	NZ,PPA_IO3		; BAIL OUT ON ERROR
;
	; SETUP LBA
	; 3 BYTES, LITTLE ENDIAN -> BIG ENDIAN
	LD	HL,PPA_CMD_RW+1		; START OF LBA FIELD IN CDB (MSB)
	LD	A,(IY+PPA_LBA+2)	; THIRD BYTE OF LBA FIELD IN CFG (MSB)
	LD	(HL),A
	INC	HL
	LD	A,(IY+PPA_LBA+1)
	LD	(HL),A
	INC	HL
	LD	A,(IY+PPA_LBA+0)
	LD	(HL),A
	INC	HL
;
	; DO SCSI IO
	LD	DE,(PPA_DSKBUF)		; DISK BUFFER TO DE
	LD	BC,512			; ONE SECTOR, 512 BYTES
	LD	HL,PPA_CMD_RW		; POINT TO READ/WRITE CMD TEMPLATE
	CALL	PPA_RUNCMD		; RUN THE SCSI ENGINE
	CALL	Z,PPA_CHKCMD		; IF EXIT OK, CHECK SCSI RESULTS
	JR	NZ,PPA_IO2		; IF ERROR, SKIP INCREMENT
	; INCREMENT LBA
	LD	A,PPA_LBA		; LBA OFFSET
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	INC32HL			; INCREMENT THE VALUE
	; INCREMENT DMA
	LD	HL,PPA_DSKBUF+1		; POINT TO MSB OF BUFFER ADR
	INC	(HL)			; BUMP DMA BY
	INC	(HL)			; ... 512 BYTES
	XOR	A			; SIGNAL SUCCESS
;
PPA_IO2:
PPA_IO3:
	LD	HL,(PPA_DSKBUF)		; CURRENT DMA TO HL
	OR	A			; SET FLAGS BASED ON RETURN CODE
	RET	Z			; RETURN IF SUCCESS
	LD	A,ERR_IO		; SIGNAL IO ERROR
	OR	A			; SET FLAGS
	RET				; AND DONE
;
;
;
PPA_STATUS:
	; RETURN UNIT STATUS
	LD	A,(IY+PPA_STAT)		; GET STATUS OF SELECTED DEVICE
	OR	A			; SET FLAGS
	RET				; AND RETURN
;
;
;
PPA_RESET:
	JP	PPA_INITDEV		; JUST (RE)INIT DEVICE
;
;
;
PPA_DEVICE:
	LD	D,DIODEV_PPA		; D := DEVICE TYPE
	LD	E,(IY+PPA_DEV)		; E := PHYSICAL DEVICE NUMBER
	LD	C,%01000000		; C := REMOVABLE HARD DISK
	LD	H,(IY+PPA_MODE)		; H := MODE
	LD	L,(IY+PPA_IOBASE)	; L := BASE I/O ADDRESS
	XOR	A			; SIGNAL SUCCESS
	RET
;
; PPA_GETMED
;
PPA_MEDIA:
	LD	A,E			; GET FLAGS
	OR	A			; SET FLAGS
	JR	Z,PPA_MEDIA1		; JUST REPORT CURRENT STATUS AND MEDIA
;
	CALL	PPA_RESET		; RESET INCLUDES MEDIA CHECK
;
PPA_MEDIA1:
	LD	A,(IY+PPA_STAT)		; GET STATUS
	OR	A			; SET FLAGS
	LD	D,0			; NO MEDIA CHANGE DETECTED
	LD	E,MID_HD		; ASSUME WE ARE OK
	RET	Z			; RETURN IF GOOD INIT
	LD	E,MID_NONE		; SIGNAL NO MEDIA
	LD	A,ERR_NOMEDIA		; NO MEDIA ERROR
	OR	A			; SET FLAGS
	RET				; AND RETURN
;
;
;
PPA_SEEK:
	BIT	7,D			; CHECK FOR LBA FLAG
	CALL	Z,HB_CHS2LBA		; CLEAR MEANS CHS, CONVERT TO LBA
	RES	7,D			; CLEAR FLAG REGARDLESS (DOES NO HARM IF ALREADY LBA)
	LD	(IY+PPA_LBA+0),L	; SAVE NEW LBA
	LD	(IY+PPA_LBA+1),H	; ...
	LD	(IY+PPA_LBA+2),E	; ...
	LD	(IY+PPA_LBA+3),D	; ...
	XOR	A			; SIGNAL SUCCESS
	RET				; AND RETURN
;
;
;
PPA_CAP:
	LD	A,(IY+PPA_STAT)		; GET STATUS
	PUSH	AF			; SAVE IT
	LD	A,PPA_MEDCAP		; OFFSET TO CAPACITY FIELD
	CALL	LDHLIYA			; HL := IY + A, REG A TRASHED
	CALL	LD32			; GET THE CURRENT CAPACITY INTO DE:HL
	LD	BC,512			; 512 BYTES PER BLOCK
	POP	AF			; RECOVER STATUS
	OR	A			; SET FLAGS
	RET
;
;
;
PPA_GEOM:
	; FOR LBA, WE SIMULATE CHS ACCESS USING 16 HEADS AND 16 SECTORS
	; RETURN HS:CC -> DE:HL, SET HIGH BIT OF D TO INDICATE LBA CAPABLE
	CALL	PPA_CAP			; GET TOTAL BLOCKS IN DE:HL, BLOCK SIZE TO BC
	LD	L,H			; DIVIDE BY 256 FOR # TRACKS
	LD	H,E			; ... HIGH BYTE DISCARDED, RESULT IN HL
	LD	D,16 | $80		; HEADS / CYL = 16, SET LBA CAPABILITY BIT
	LD	E,16			; SECTORS / TRACK = 16
	RET				; DONE, A STILL HAS PPA_CAP STATUS
;
;=============================================================================
; FUNCTION SUPPORT ROUTINES
;=============================================================================
;
;
;
PPA_DELAY:
	PUSH	AF
	CALL	DELAY
	CALL	DELAY
	CALL	DELAY
	CALL	DELAY
	POP	AF
	RET
;
;
;
PPA_WAITDONE:
	LD	HL,0			; TIMEOUT COUNTER
PPA_WAITDONE1:
	CALL	PPA_READSTATUS
	AND	$F0
	BIT	7,A
	RET	NZ
	DEC	HL
	LD	A,H
	OR	L
	JP	Z,IMM_CMD_TIMEOUT	; TIMEOUT
	JR	PPA_WAITDONE1
;
; OUTPUT BYTE IN A TO THE DATA PORT
;
PPA_WRITEDATA:
	LD	C,(IY+PPA_IOBASE)	; DATA PORT IS AT IOBASE
	OUT	(C),A			; WRITE THE BYTE
	;CALL	DELAY			; IS THIS NEEDED???
	RET				; DONE
;
;
;
PPA_WRITECTRL:
	; IBM PC INVERTS ALL BUT C2 ON THE BUS, MG014 DOES NOT.
	; BELOW TRANSLATES FROM IBM -> MG014.	IT ALSO INVERTS THE
	; MG014 LED SIMPLY TO MAKE IT EASY TO KEEP LED ON DURING
	; ALL ACTIVITY.
#IF (PPAMODE == PPAMODE_MG014
	XOR	$0B | $80		; HIGH BIT IS MG014 LED
#ENDIF
	LD	C,(IY+PPA_IOBASE)	; GET BASE IO ADDRESS
	INC	C			; BUMP TO CONTROL PORT
	INC	C
	OUT	(C),A			; WRITE TO CONTROL PORT
	;CALL	DELAY			; IS THIS NEEDED?
	RET				; DONE
;
; READ THE PARALLEL PORT INPUT LINES (STATUS) AND MAP SIGNALS FROM
; MG014 TO IBM STANDARD.  NOTE POLARITY CHANGE REQUIRED FOR BUSY.
;
; 	MG014		IBM PC
;	--------	--------
;	0: /ACK		6: /ACK
;	1: BUSY		7: /BUSY
;	2: POUT		5: POUT
;	3: SEL		4: SEL
;	4: /ERR		3: /ERR
;
PPA_READSTATUS:
	LD	C,(IY+PPA_IOBASE)	; IOBASE TO C
	INC	C			; BUMP TO STATUS PORT
	IN	A,(C)			; READ IT
;
#IF (PPAMODE == PPAMODE_MG014
;
	; SHUFFLE BITS ON MG014
	LD	C,0			; INIT RESULT
	BIT	0,A			; 0: /ACK
	JR	Z,PPA_READSTATUS1
	SET	6,C			; 6: /ACK
PPA_READSTATUS1:
	BIT	1,A			; 1: BUSY
	JR	NZ,PPA_READSTATUS2	; POLARITY CHANGE!
	SET	7,C			; 7: /BUSY
PPA_READSTATUS2:
	BIT	2,A			; 2: POUT
	JR	Z,PPA_READSTATUS3
	SET	5,C			; 5: POUT
PPA_READSTATUS3:
	BIT	3,A			; 3: SEL
	JR	Z,PPA_READSTATUS4
	SET	4,C			; 4: SEL
PPA_READSTATUS4:
	BIT	4,A			; 4: /ERR
	JR	Z,PPA_READSTATUS5
	SET	3,C			; 3: /ERR
PPA_READSTATUS5:
	LD	A,C			; RESULT TO A
;
#ENDIF
;
	RET
;
;
;
PPA_DPULSE:
	CALL	PPA_WRITEDATA
	LD	A,$0C \ CALL	PPA_WRITECTRL
	LD	A,$0E \ CALL	PPA_WRITECTRL
	LD	A,$0C \ CALL	PPA_WRITECTRL
	LD	A,$04 \ CALL	PPA_WRITECTRL
	LD	A,$0C \ CALL	PPA_WRITECTRL
	RET
;
;
;
PPA_CPULSE:
	CALL	PPA_WRITEDATA
	LD	A,$04 \ CALL	PPA_WRITECTRL
	LD	A,$06 \ CALL	PPA_WRITECTRL
	LD	A,$04 \ CALL	PPA_WRITECTRL
	LD	A,$0C \ CALL	PPA_WRITECTRL
	RET
;
;
;
PPA_CONNECT:
	LD	A,$00 \ CALL	PPA_CPULSE
	LD	A,$3C \ CALL	PPA_CPULSE
	LD	A,$20 \ CALL	PPA_CPULSE
	LD	A,$8F \ CALL	PPA_CPULSE
	RET
;
;
;
PPA_DISCONNECT:
	LD	A,$00 \ CALL	PPA_DPULSE
	LD	A,$3C \ CALL	PPA_DPULSE
	LD	A,$20 \ CALL	PPA_DPULSE
	LD	A,$0F \ CALL	PPA_DPULSE
	RET
;
; SCSI SELECT PROCESS
;
;
PPA_SELECT:
	LD	A,1 << PPA_TGT
	CALL	PPA_WRITEDATA
	LD	A,$0E \ CALL	PPA_WRITECTRL
	LD	A,$0C \ CALL	PPA_WRITECTRL
	LD	A,1 << PPA_SELF
	CALL	PPA_WRITEDATA
	LD	A,$08 \ CALL	PPA_WRITECTRL
;
	LD	HL,0			; TIMEOUT COUNTER
;
PPA_SELECT1:
	CALL	PPA_READSTATUS
	OR	$F0
	RET	NZ
	DEC	HL
	LD	A,H
	OR	L
	RET	Z			; TIMEOUT
	JR	PPA_SELECT1
;
; SEND SCSI CMD BYTE STRING.  AT ENTRY, HL POINTS TO START OF
; COMMAND BYTES.  THE LENGTH OF THE COMMAND STRING MUST PRECEED
; THE COMMAND BYTES (HL - 1).
;
; NOTE THAT DATA IS SENT AS BYTE PAIRS!  EACH LOOP SENDS 2 BYTES.
; DATA OUTPOUT IS BURSTED (NO CHECK FOR BUSY).  SEEMS TO WORK FINE.
;
PPA_SENDCMD:
	JP	PPA_ERR			; NOW DO STANDARD ERR PROCESSING
;
; THIS IS THE MAIN SCSI ENGINE.  BASICALLY, IT SELECTS THE DEVICE
; ON THE BUS, SENDS THE COMMAND, THEN PROCESSES THE RESULT.
;
; HL: COMMAND BUFFER
; DE: TRANSFER BUFFER
; BC: TRANSFER LENGTH (0=VARIABLE)
;
PPA_RUNCMD:
	JP	PPA_ERR			; NOW DO STANDARD ERR PROCESSING
;
; ERRORS SHOULD GENERALLY NOT CAUSE SCSI PROCESSING TO FAIL.  IF A
; DEVICE ERROR (I.E., READ ERROR) OCCURS, THEN THE SCSI PROTOCOL WILL
; PROVIDE ERROR INFORMATION.  THE STATUS RESULT OF THE SCSI COMMAND
; WILL INDICATE IF AN ERROR OCCURRED.  ADDITIONALLY, IF THE ERROR IS
; A CHECK CONDITION ERROR, THEN IT IS MANDATORY TO ISSUE A SENSE
; REQUEST SCSI COMMAND TO CLEAR THE ERROR AND RETRIEVE DETAILED ERROR
; INFO.
;
PPA_CHKCMD:
	; SCSI COMMAND COMPLETED, CHECK SCSI CMD STATUS
	LD	A,(PPA_CMDSTAT)		; GET STATUS BYTE
	OR	A			; SET FLAGS
	RET	Z			; IF ZERO, ALL GOOD, DONE
;
	; DO WE HAVE A CHECK CONDITION?
	CP	2			; CHECK CONDITION RESULT?
	JR	Z,PPA_CHKCMD1		; IF SO, REQUEST SENSE
	JP	PPA_IOERR		; ELSE, GENERAL I/O ERROR
;
PPA_CHKCMD1:
	; USE REQUEST SENSE CMD TO GET ERROR DETAILS
	LD	DE,HB_WRKBUF		; PUT DATA IN WORK BUF
	LD	BC,0			; VARIABLE LENGTH REQUEST
	LD	HL,PPA_CMD_SENSE	; REQUEST SENSE CMD
	CALL	PPA_RUNCMD		; DO IT
	JP	NZ,PPA_IOERR		; BAIL IF ERROR IN CMD
;
	; REQ SENSE CMD COMPLETED
#IF (PPATRACE >= 3)
	LD	A,16
	LD	DE,HB_WRKBUF
	CALL	Z,PRTHEXBUF
#ENDIF
;
	; CHECK SCSI CMD STATUS
	LD	A,(PPA_CMDSTAT)		; GET STATUS BYTE
	OR	A			; SET FLAGS
	JP	NZ,PPA_IOERR		; IF FAILED, GENERAL I/O ERROR
;
	; RETURN RESULT BASED ON REQ SENSE DATA
	; TODO: WE NEED TO CHECK THE SENSE KEY FIRST!!!
	LD	A,(HB_WRKBUF+12)	; GET ADDITIONAL SENSE CODE
	CP	$3A			; NO MEDIA?
	JP	Z,PPA_NOMEDIA		; IF SO, RETURN NO MEDIA ERR
	JP	PPA_IOERR		; ELSE GENERAL I/O ERR
;
; CHECK CURRENT DEVICE FOR ERROR STATUS AND ATTEMPT TO RECOVER
; VIA RESET IF DEVICE IS IN ERROR.
;
PPA_CHKERR:
	LD	A,(IY+PPA_STAT)		; GET STATUS
	OR	A			; SET FLAGS
	CALL	NZ,PPA_RESET		; IF ERROR STATUS, RESET BUS
	RET
;
; (RE)INITIALIZE DEVICE
;
PPA_INITDEV:
	; INITIALIZE 8255
	LD	A,(IY+PPA_IOBASE)	; BASE PORT
	ADD	A,PPA_IOSETUP		; BUMP TO SETUP PORT
	LD	C,A			; MOVE TO C FOR I/O
	LD	A,$82			; CONFIG A OUT, B IN, C OUT
	OUT	(C),A			; DO IT
	CALL	DELAY			; SHORT DELAY FOR BUS SETTLE
;
	JP	PPA_NOTSUP
;
;=============================================================================
; ERROR HANDLING AND DIAGNOSTICS
;=============================================================================
;
; ERROR HANDLERS
;
;
PPA_NOMEDIA:
	LD	A,PPA_STNOMEDIA
	JR	PPA_ERR
;
PPA_CMDERR:
	LD	A,PPA_STCMDERR
	JR	PPA_ERR
;
PPA_IOERR:
	LD	A,PPA_STIOERR
	JR	PPA_ERR
;
PPA_TO:
	LD	A,PPA_STTO
	JR	PPA_ERR
;
PPA_NOTSUP:
	LD	A,PPA_STNOTSUP
	JR	PPA_ERR
;
PPA_ERR:
	LD	(IY+PPA_STAT),A		; SAVE NEW STATUS
;
PPA_ERR2:
#IF (PPATRACE >= 1)
	CALL	PPA_PRTSTAT
#ENDIF
	OR	A			; SET FLAGS
	RET
;
;
;
PPA_PRTERR:
	RET	Z			; DONE IF NO ERRORS
	; FALL THRU TO PPA_PRTSTAT
;
; PRINT FULL DEVICE STATUS LINE
;
PPA_PRTSTAT:
	PUSH	AF
	PUSH	DE
	PUSH	HL
	LD	A,(IY+PPA_STAT)
	CALL	PPA_PRTPREFIX		; PRINT UNIT PREFIX
	CALL	PC_SPACE		; FORMATTING
	CALL	PPA_PRTSTATSTR
	POP	HL
	POP	DE
	POP	AF
	RET
;
; PRINT STATUS STRING
;
PPA_PRTSTATSTR:
	PUSH	AF
	PUSH	DE
	PUSH	HL
	LD	A,(IY+PPA_STAT)
	NEG
	LD	HL,PPA_STR_ST_MAP
	ADD	A,A
	CALL	ADDHLA
	LD	E,(HL)
	INC	HL
	LD	D,(HL)
	CALL	WRITESTR
	POP	HL
	POP	DE
	POP	AF
	RET
;
; PRINT DIAGNONSTIC PREFIX
;
PPA_PRTPREFIX:
	PUSH	AF
	CALL	NEWLINE
	PRTS("PPA$")
	LD	A,(IY+IMM_DEV)		; GET CURRENT DEVICE NUM
	CALL	PRTDECB
	CALL	PC_COLON
	POP	AF
	RET
;
;=============================================================================
; STRING DATA
;=============================================================================
;
PPA_STR_ST_MAP:
	.DW		PPA_STR_STOK
	.DW		PPA_STR_STNOMEDIA
	.DW		PPA_STR_STCMDERR
	.DW		PPA_STR_STIOERR
	.DW		PPA_STR_STTO
	.DW		PPA_STR_STNOTSUP
;
PPA_STR_STOK		.TEXT	"OK$"
PPA_STR_STNOMEDIA	.TEXT	"NO MEDIA$"
PPA_STR_STCMDERR	.TEXT	"COMMAND ERROR$"
PPA_STR_STIOERR		.TEXT	"IO ERROR$"
PPA_STR_STTO		.TEXT	"TIMEOUT$"
PPA_STR_STNOTSUP	.TEXT	"NOT SUPPORTED$"
PPA_STR_STUNK		.TEXT	"UNKNOWN ERROR$"
;
PPA_STR_MODE_MAP:
	.DW	PPA_STR_MODE_NONE
	.DW	PPA_STR_MODE_SPP
	.DW	PPA_STR_MODE_MG014
;
PPA_STR_MODE_NONE	.DB	"NONE$"
PPA_STR_MODE_SPP	.DB	"SPP$"
PPA_STR_MODE_MG014	.DB	"MG014$"
;
PPA_STR_NOHW		.TEXT	"NOT PRESENT$"
;
;=============================================================================
; DATA STORAGE
;=============================================================================
;
PPA_DEVNUM	.DB	0		; TEMP DEVICE NUM USED DURING INIT
PPA_CMDSTK	.DW	0		; STACK PTR FOR CMD ABORTING
PPA_DSKBUF	.DW	0		; WORKING DISK BUFFER POINTER
PPA_XFRLEN	.DW	0		; WORKING TRANSFER LENGTH
PPA_CMDSTAT	.DB	0, 0		; CMD RESULT STATUS
;
; SCSI COMMAND TEMPLATES (LENGTH PREFIXED)
;
		.DB	6
PPA_CMD_RW	.DB	$00, $00, $00, $00, $01, $00	; READ/WRITE SECTOR
		.DB	6
PPA_CMD_SENSE	.DB	$03, $00, $00, $00, $FF, $00	; REQUEST SENSE DATA
		.DB	10
PPA_CMD_RDCAP	.DB	$25, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; READ CAPACITY
;
; PPA DEVICE CONFIGURATION TABLE
;
PPA_CFG:
;
#IF (PPACNT >= 1)
;
PPA0_CFG:	; DEVICE 0
	.DB	0			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
	.DB	PPAMODE			; DRIVER DEVICE MODE
	.DB	0			; DEVICE STATUS
	.DB	PPA0BASE		; IO BASE ADDRESS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
#ENDIF
;
#IF (PPACNT >= 2)
;
PPA1_CFG:	; DEVICE 1
	.DB	0			; DRIVER DEVICE NUMBER (FILLED DYNAMICALLY)
	.DB	PPAMODE			; DRIVER DEVICE MODE
	.DB	0			; DEVICE STATUS
	.DB	PPA1BASE		; IO BASE ADDRESS
	.DW	0,0			; DEVICE CAPACITY
	.DW	0,0			; CURRENT LBA
#ENDIF
;
#IF ($ - PPA_CFG) != (PPACNT * PPA_CFGSIZ)
	.ECHO	"*** INVALID PPA CONFIG TABLE ***\n"
#ENDIF
;
	.DB	$FF			; END MARKER
